<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="前端面试题-js(补充中...)">
<meta property="og:url" content="http://example.com/2018/05/12/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98js/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-05-12T09:23:59.000Z">
<meta property="article:modified_time" content="2024-03-05T09:00:12.772Z">
<meta property="article:author" content="小川">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2018/05/12/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98js/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>前端面试题-js(补充中...) | 学习笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">学习笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">孜孜不倦，蒸蒸日上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">68</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/12/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小川">
      <meta itemprop="description" content="留一片空白，随时浓墨重彩">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端面试题-js(补充中...)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-12 17:23:59" itemprop="dateCreated datePublished" datetime="2018-05-12T17:23:59+08:00">2018-05-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          
            <span id="/2018/05/12/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98js/" class="post-meta-item leancloud_visitors" data-flag-title="前端面试题-js(补充中...)" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

   <!--
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>  -->
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/05/12/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98js/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/05/12/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98js/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<span id="more"></span>

<h3 id="Var、-let-、const-区别"><a href="#Var、-let-、const-区别" class="headerlink" title="Var、 let 、const 区别"></a>Var、 let 、const 区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相同点:</span><br><span class="line"><span class="keyword">var</span>、<span class="keyword">let</span>、<span class="keyword">const</span>三者都可以声明变量</span><br><span class="line">区别:</span><br><span class="line"><span class="keyword">var</span> 存在变量提升 而<span class="keyword">let</span> 与 <span class="keyword">const</span> 不存在变量提升</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 定义的变量可以声明多次，而<span class="keyword">let</span>、<span class="keyword">const</span>定义的变量只能声明一次</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>、<span class="keyword">let</span>声明的变量可以再次赋值，而<span class="keyword">const</span>声明的变量不能再次赋值</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 声明的变量没有自身的作用域(<span class="keyword">var</span>没有块级作用域)，而<span class="keyword">let</span>、<span class="keyword">const</span>声明的变量有自身的作用域 (在函数内<span class="keyword">var</span>声明的变量，在函数外也可以调用，但<span class="keyword">let</span>、<span class="keyword">const</span>声明的变量有自身的作用域，在函数内定义的变量只能在函数内使用)</span><br></pre></td></tr></table></figure>
<h3 id="ES6声明变量的六种方法"><a href="#ES6声明变量的六种方法" class="headerlink" title="ES6声明变量的六种方法"></a>ES6声明变量的六种方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ES5: <span class="keyword">var</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"><span class="title">ES6</span>: <span class="title">let</span> <span class="title">const</span> <span class="title">import</span> <span class="title">class</span>(<span class="params"><span class="keyword">class</span>类</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="函数声明与函数表达式的区别"><a href="#函数声明与函数表达式的区别" class="headerlink" title="函数声明与函数表达式的区别"></a>函数声明与函数表达式的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明(函数名是必须的)</span></span><br><span class="line">函数声明的最重要的一个特征是函数声明提升，意思是在执行代码之前会先读取函数声明，所以函数声明可以放在调用函数语句之后(类似于变量提升)</span><br><span class="line"></span><br><span class="line">sayHello();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式(函数名可写，可不写)</span></span><br><span class="line">这种形式看起来像常规的变量赋值，先创建一个匿名函数，然后赋值给变量sayHi(不存在提升)</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">//在这里调用会报错</span></span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayHi(); <span class="comment">//Hi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有趣的javascript例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;());</span><br><span class="line">在chrome中输出<span class="string">&quot;I am inside&quot;</span>,IE11直接报错,firefox低一点的版本输出<span class="string">&quot;I am outside&quot;</span>…</span><br><span class="line"></span><br><span class="line">chrome输出的结果很明确的反应了用函数声明式声明的函数的特点–函数在声明之前就可以调用.</span><br><span class="line"></span><br><span class="line">IE报错显示缺少对象,因为函数声明在了条件里,违背了函数声明式的原则</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数表达式的作用域:</span><br><span class="line"></span><br><span class="line">如果函数表达式声明的函数有函数名,那么这个函数名就相当于这个函数的一个局部变量,只能在函数内部调用,举个栗子:</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (x &lt;= <span class="number">1</span>) </span><br><span class="line">	    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	    <span class="keyword">return</span> x*fact(x-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fact());   <span class="comment">// Uncaught ReferenceError: fact is not defined</span></span><br><span class="line">fact()在函数内部可以调用,在函数外部调用就会报错:fact未定义.</span><br></pre></td></tr></table></figure>
<h3 id="函数柯里化-参考"><a href="#函数柯里化-参考" class="headerlink" title="函数柯里化 参考"></a>函数柯里化 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44865458/article/details/116463781?spm=1001.2014.3001.5502">参考</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术 优点： <span class="number">1</span>、参数复用 <span class="number">2</span>、提前确认 <span class="number">3</span>、延迟运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="宏任务和微任务到底是什么"><a href="#宏任务和微任务到底是什么" class="headerlink" title="宏任务和微任务到底是什么"></a>宏任务和微任务到底是什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面试题</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行顺序</span></span><br><span class="line">start </span><br><span class="line">promise</span><br><span class="line">end</span><br><span class="line">then1</span><br><span class="line">then2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）js是单线程的，但是分同步异步\</span><br><span class="line">（<span class="number">2</span>）微任务和宏任务皆为异步任务，它们都属于一个队列\</span><br><span class="line">（<span class="number">3</span>）宏任务一般是：script、<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>、postMessage、MessageChannel、setImmediate(Node.js 环境)\</span><br><span class="line">（<span class="number">4</span>）微任务：<span class="built_in">Promise</span>.then、<span class="built_in">Object</span>.observe、MutationObserver、process.nextTick(Node.js 环境)\</span><br><span class="line">（<span class="number">5</span>）先执行同步再执行异步，异步遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务</span><br><span class="line"></span><br><span class="line">- 宏任务一般是：&lt;script&gt;标签中的运行代码、<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>、postMessage、MessageChannel、setImmediate(Node.js 环境)</span><br><span class="line">- 微任务：<span class="built_in">Promise</span>.then、<span class="built_in">Object</span>.observe、MutationObserver、process.nextTick(Node.js 环境)</span><br><span class="line"></span><br><span class="line">宏任务、微任务是怎么执行的？</span><br><span class="line"></span><br><span class="line">执行顺序：先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，遇到异步微任务则将异步微任务放入微任务队列中，当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕</span><br><span class="line"></span><br><span class="line">这里容易产生一个**错误的**认识：就是微任务先于宏任务执行。实际上是先执行同步任务然后在执行异步任务，异步任务是分宏任务和微任务两种的</span><br><span class="line"></span><br><span class="line">JS是单线程的，那么JS是如何实现并发请求的？</span><br><span class="line">一般情况下，在单线程中，所有的任务需要排队，前一个任务执行完毕之后，才会去执行下一个任务，如果前一个任务耗时很长，后一个任务就不得不一直等着，那么JS是如何实现并发请求的呢？或者说JS是如何实现异步请求的呢？答案就是因为有 消息队列 和 事件循环 的存在</span><br><span class="line"></span><br><span class="line">消息队列指的是一个先进先出的队列，在这个队列中可以存在各种消息</span><br><span class="line"></span><br><span class="line">事件循环指的是主线程重复从消息队列中获取消息、执行的过程</span><br><span class="line"></span><br><span class="line">事件循环的基本流程</span><br><span class="line">JS的主线程一般只会做一件事情，就是从消息队列里取出消息，然后执行消息，再取出消息然后再执行，当消息队列为空时，就会等待直到消息队列中有消息的存在，而且主线程只有再将当前的消息执行完成之后，才会去执行下一个消息，这种机制就是事件循环机制</span><br><span class="line"></span><br><span class="line">事件循环的例子</span><br><span class="line">请看下面的一段代码，我们来详细介绍下事件循环中代码的执行流程是什么？</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;process.nextTick1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;process.nextTick2&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise then&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;main2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">正确的执行顺序请看下方的结果：</span><br><span class="line"></span><br><span class="line">main1</span><br><span class="line">promise</span><br><span class="line">main2</span><br><span class="line">process.nextTick1</span><br><span class="line">promise then</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line">process.nextTick2</span><br><span class="line"></span><br><span class="line">详细分析：</span><br><span class="line">事件循环在执行上流程上，首先将全局代码当作一个宏任务，会先执行这个宏任务，执行这个宏任务的时候，会首先执行同步代码，遇到微任务就添加到微任务队列，遇到宏任务就会添加到宏任务队列，当同步代码执行完毕的时候，会开始执行微任务队列中的任务，执行完毕之后会执行宏任务队列中的任务，所以，本题最重要的就是要区分好宏任务是什么，微任务是什么，<span class="built_in">setTimeout</span>中的回调函数时宏任务，process.nextTick是微任务，所以执行顺序是上面的结果</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;		    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;		    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line"><span class="comment">// 2 5 3 4 1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>遇到setTimout，异步宏任务，放入宏任务队列中</span><br><span class="line"><span class="number">2.</span>遇到<span class="keyword">new</span> <span class="built_in">Promise</span>，<span class="keyword">new</span> <span class="built_in">Promise</span>在实例化的过程中所执行的代码都是同步进行的，所以输出<span class="number">2</span></span><br><span class="line"><span class="number">3.</span>而<span class="built_in">Promise</span>.then中注册的回调才是异步执行的，将其放入微任务队列中</span><br><span class="line"><span class="number">4.</span>遇到同步任务<span class="built_in">console</span>.log(‘<span class="number">5</span>’);输出<span class="number">5</span>；主线程中同步任务执行完</span><br><span class="line"><span class="number">5.</span>从微任务队列中取出任务到主线程中，输出<span class="number">3</span>、 <span class="number">4</span>，微任务队列为空</span><br><span class="line"><span class="number">6.</span>从宏任务队列中取出任务到主线程中，输出<span class="number">1</span>，宏任务队列为空</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;before timeout&#x27;</span>);</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;also before timeout&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>遇到<span class="built_in">setTimeout</span>，异步宏任务，将() =&gt; &#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;放入宏任务队列中；</span><br><span class="line"><span class="number">2.</span>遇到<span class="keyword">new</span> <span class="built_in">Promise</span>，<span class="keyword">new</span> <span class="built_in">Promise</span>在实例化的过程中所执行的代码都是同步进行的，所以输出<span class="number">1</span>；</span><br><span class="line"><span class="number">3.</span>而<span class="built_in">Promise</span>.then中注册的回调才是异步执行的，将其放入微任务队列中</span><br><span class="line"><span class="number">4.</span>遇到同步任务<span class="built_in">console</span>.log(<span class="number">2</span>)，输出<span class="number">2</span>；主线程中同步任务执行完</span><br><span class="line"><span class="number">5.</span>从微任务队列中取出任务到主线程中，输出<span class="number">3</span>，此微任务中又有微任务，<span class="built_in">Promise</span>.resolve().then(微任务a).then(微任务b)，将其依次放入微任务队列中；</span><br><span class="line"><span class="number">6.</span>从微任务队列中取出任务a到主线程中，输出 before timeout；</span><br><span class="line"><span class="number">7.</span>从微任务队列中取出任务b到主线程中，任务b又注册了一个微任务c，放入微任务队列中；</span><br><span class="line"><span class="number">8.</span>从微任务队列中取出任务c到主线程中，输出 also before timeout；微任务队列为空</span><br><span class="line"><span class="number">9.</span>从宏任务队列中取出任务到主线程，此任务中注册了一个微任务d，将其放入微任务队列中，接下来遇到输出<span class="number">4</span>，宏任务队列为空</span><br><span class="line"><span class="number">10.</span>从微任务队列中取出任务d到主线程 ，输出test，微任务队列为空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 7 6 8 2 4 3 5 9 11 10 12</span></span><br></pre></td></tr></table></figure>
<h3 id="如何判断变量为-NaN-Not-a-Number，非数字"><a href="#如何判断变量为-NaN-Not-a-Number，非数字" class="headerlink" title="如何判断变量为 NaN( Not a Number，非数字)"></a>如何判断变量为 NaN( Not a Number，非数字)</h3><p>NaN不能用相等操作符(== 和 ===) 来判断， NaN === NaN 会返回 false<br>虽然 NaN 是“Not a Number”，但是它的类型还是数值类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过isNaN()判断,isNaN()会先将参数转为Number 类型</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>)     <span class="comment">// 返回true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1000</span>)    <span class="comment">// 返回false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;小明&#x27;</span>)  <span class="comment">// 返回true（判断前会转换成number类型）</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;101&#x27;</span>)   <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure>
<h3 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="headerlink" title="null 和 undefined 区别"></a>null 和 undefined 区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    总的来说 <span class="literal">null</span> 和 <span class="literal">undefined</span> 都代表空, <span class="literal">null</span>是一个关键字，表示一个空值的对象引用，<span class="literal">undefined</span>表示一个未定义的值，用作默认初始值</span><br><span class="line"><span class="comment">//typeof</span></span><br><span class="line">    <span class="keyword">typeof</span> <span class="literal">null</span>  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">    <span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="literal">null</span> <span class="comment">// 显式地将a赋值给null</span></span><br><span class="line">    <span class="keyword">let</span> b;       <span class="comment">// b的默认值为undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 输出 null</span></span><br><span class="line">    <span class="built_in">console</span>.log(b) <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="comment">//== 与 ===</span></span><br><span class="line">    <span class="literal">null</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line">    <span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line">    !!<span class="literal">null</span> === !!<span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">//+ 运算 与 Number()   </span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="literal">undefined</span> + <span class="number">1</span>  <span class="comment">// NaN</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="literal">null</span> + <span class="number">1</span>  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">Number</span>(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br><span class="line">    <span class="built_in">Number</span>(<span class="literal">null</span>)  <span class="comment">// 0 </span></span><br></pre></td></tr></table></figure>
<h3 id="JS实现继承的方式有哪些？"><a href="#JS实现继承的方式有哪些？" class="headerlink" title="JS实现继承的方式有哪些？"></a>JS实现继承的方式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数继承 原型链继承 组合继承 寄生组合继承 ES6类(<span class="class"><span class="keyword">class</span>类)继承</span></span><br></pre></td></tr></table></figure>
<h3 id="内存中的堆和栈"><a href="#内存中的堆和栈" class="headerlink" title="内存中的堆和栈"></a>内存中的堆和栈</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">栈：先进后出，自动分配释放</span><br><span class="line">堆：先进先出，手动释放，容易内存泄漏</span><br><span class="line"></span><br><span class="line">基本数据类型：<span class="literal">null</span>、<span class="literal">undefined</span>、<span class="built_in">String</span>、<span class="built_in">Number</span>、<span class="built_in">Boolean</span>、<span class="built_in">Symbol</span>(ES6) 基本数据类型可以直接访问，</span><br><span class="line">按值进行分配，存放在**栈内存**中的简单数据段</span><br><span class="line">引用型：OBject，存放在**堆内存**中，实际栈保存的是一个指针，这个指针指向另一个位置（**堆内存**）</span><br></pre></td></tr></table></figure>
<h3 id="和-区别"><a href="#和-区别" class="headerlink" title="== 和 ===区别"></a>== 和 ===区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">相等操作符（==）不会判断数据类型，</span><br><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">全等运算符(===)会判断数据类型</span><br><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="如何来区分js数据类型的-比如区分对象和数组"><a href="#如何来区分js数据类型的-比如区分对象和数组" class="headerlink" title="如何来区分js数据类型的?比如区分对象和数组"></a>如何来区分js数据类型的?比如区分对象和数组</h3><p>判断数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 toString 方式 （返回[object constructorName]的字符串格式）</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span> ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Array.isArray(arr) 来判断值是否为数组</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.isArray( arr ) ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 instanceof 方式 （用来检测构造函数的prototype 属性是否出现在某个对象的原型链上）</span></span><br><span class="line"><span class="built_in">console</span>.log( arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 constructor 方式  （constructor是prototype对象的一个属性，指向的是prototype属性所在的构造函数，可以判断数据类型）</span></span><br><span class="line"><span class="built_in">console</span>.log( arr.constructor === <span class="built_in">Array</span> ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 __proto__ 方式（意思为实例的__proto__属性，是否指向构造函数的prototype属性） (PS: .__proto__前后两个下划线)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr.__proto__  === <span class="built_in">Array</span>.prototype ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 isPrototypeOf 方式 （用于测试一个对象是否存在于另一个对象的原型链上）</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Array</span>.prototype.isPrototypeOf( arr ) ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Object.getPrototypeOf 方式 （返回指定对象的原型，内部[[Prototype]]属性的值）</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( arr ) === <span class="built_in">Array</span>.prototype ) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>判断对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//toString 方式（返回[object constructorName]的字符串格式）</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object object]&#x27;</span> ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用instanceof关键字来判断（用来检测构造函数的prototype 属性是否出现在某个对象的原型链上）</span></span><br><span class="line"><span class="built_in">console</span>.log( obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 constructor 来判断；（constructor是prototype对象的一个属性，指向的是prototype属性所在的构造函数，可以判断数据类型）</span></span><br><span class="line"><span class="built_in">console</span>.log( obj.constructor === <span class="built_in">Object</span> ) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typeof 来判断（返回对应的数据类型，数组不行）</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> ) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">引用类型判断</span><br><span class="line"></span><br><span class="line">区别对象、数组、函数可以使用<span class="built_in">Object</span>.prototype.toString.call 方法。判断某个对象值属于哪种内置类型。</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>))          <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;123&#x27;</span>))        <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>))    <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>))         <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;))           <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]))           <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>));        <span class="comment">// [object Window]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="前端开发中常用的几种设计模式-参考1、参考2"><a href="#前端开发中常用的几种设计模式-参考1、参考2" class="headerlink" title="前端开发中常用的几种设计模式 参考1、参考2"></a>前端开发中常用的几种设计模式 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32442973/article/details/119757216">参考1</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/caishijian2008/article/details/106215165">参考2</a></h3><p>设计模式可以分为三大类：</p>
<p>结构型模式(Structural Patterns): 通过识别系统中组件间的简单关系来简化系统的设计。<br>创建型模式(Creational Patterns): 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br>行为型模式(Behavioral Patterns):用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性</p>
<h3 id="单例模式——饿汉模式-amp-amp-懒汉模式"><a href="#单例模式——饿汉模式-amp-amp-懒汉模式" class="headerlink" title="单例模式——饿汉模式&amp;&amp;懒汉模式"></a>单例模式——<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42803467/article/details/119314946">饿汉模式&amp;&amp;懒汉模式</a></h3><p>什么是单例模式？<br>    单例模式是一种常见的“设计模式”</p>
<p>单例模式的应用场景<br>    某个类，不应该有多个实例，此时就可以使用单例模式（DataSource就是一个典型的案例，一一个程序中只有一个实例，不应该实例化多个DataSource对象）。如果尝试创建多个实例，编译期就会报错</p>
<p>两种典型的方式实现单例模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">singlePattern</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先创建一个表示单例的类</span></span><br><span class="line">    <span class="comment">//我们就要求Singleton这个类只能有一个实例</span></span><br><span class="line">    <span class="comment">//饿汉模式的单例实现</span></span><br><span class="line">    <span class="comment">//饿汉模式的单例实现，“饿”指得是，只要类被加载，实例就会立刻创建（实例创建时机比较早）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">        <span class="comment">//把 构造方法  变为私有，此时在该类外部，就无法 new 这个类的实例了</span></span><br><span class="line">        private <span class="function"><span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再来创建一个 static 的成员，表示Singleton 类唯一的实例</span></span><br><span class="line">        <span class="comment">//static 和 类相关，和实例无关，类在内存中只有一份，static 成员也就只有一份</span></span><br><span class="line">        <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="comment">//new没报错是因为Singleton类是singlePattern的内部类，singlePattern是可以访问内部类的private成员的</span></span><br><span class="line">        public <span class="keyword">static</span> Singleton <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="comment">//此处得 getInstance 就是获取实例得唯一方式，不应该使用其他方式创建实例了</span></span><br><span class="line">            Singleton s = Singleton.getInstance();</span><br><span class="line">            Singleton s2 = Singleton.getInstance();</span><br><span class="line">            System.out.println(s == s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">只要类被加载，就会立刻实例化Singleton实例，后续无论怎么操作，只要严格使用getInstance，就不会出现其他实例</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">lazyPattern</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用懒汉模式来实现，Singleton类被加载的时候，不会立刻实例化</span></span><br><span class="line">    <span class="comment">//等到第一次使用这个实例的时候，再实例化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">        private <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        public <span class="keyword">static</span> Singleton <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类被加载的时候，没有立刻被实例化，第一次调用getInstance的时候，才真正的实例化</span><br><span class="line"></span><br><span class="line">如果要是代码一整场都没有调用getInstance，此时实例化的过程也就被省略掉了，又称“延时加载”</span><br><span class="line"></span><br><span class="line">一般认为“懒汉模式” 比 “饿汉模式”效率更高。</span><br><span class="line"></span><br><span class="line">懒汉模式有很大的可能是“实例用不到”，此时就节省了实例化的开销</span><br></pre></td></tr></table></figure>
<h3 id="在数组对象中添加新字段的方法"><a href="#在数组对象中添加新字段的方法" class="headerlink" title="在数组对象中添加新字段的方法"></a>在数组对象中添加新字段的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="comment">//1、Object.assign()</span></span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">    &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;,   </span><br><span class="line">    &#123;<span class="attr">age</span>:<span class="number">30</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 添加新字段</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(item,&#123;<span class="attr">name</span>:<span class="string">&#x27;井空&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item , i</span>) =&gt;</span> &#123;</span><br><span class="line">    item[<span class="string">&#x27;name&#x27;</span>] =<span class="string">&#x27;井空&#x27;</span> <span class="comment">// 和item.name=&#x27;井空&#x27;是一样得</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">//2、map() </span></span><br><span class="line">map正常情况下会跟<span class="keyword">return</span>结合使用，而map的作用就是重新整理数据结构</span><br><span class="line">有时候我们需要对后台传来的数据做一些处理，这时候使用map就可以得到想要的数据</span><br><span class="line"><span class="comment">//2.1、</span></span><br><span class="line"><span class="keyword">let</span> arr =[</span><br><span class="line">   &#123;<span class="attr">price</span>: <span class="string">&#x27;25&#x27;</span>&#125;,</span><br><span class="line">   &#123;<span class="attr">price</span>: <span class="string">&#x27;15&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> _arr = [];</span><br><span class="line">arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//下面这行代码同样适合放在上面的forEach里面</span></span><br><span class="line">	_arr.push(<span class="built_in">Object</span>.assign(&#123;&#125;,item,&#123;<span class="attr">flag</span>: <span class="literal">false</span>&#125;)) <span class="comment">//注意这个‘&#123;&#125;’,添加时原数组arr不改变，去掉之后arr数组跟_arr数组数据一样，改变了</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [&#123;price: &#x27;25&#x27;&#125;,&#123;price: &#x27;15&#x27;&#125;] </span></span><br><span class="line"><span class="built_in">console</span>.log(_arr) <span class="comment">// [&#123;price: &#x27;25&#x27;,flag: false&#125;,&#123;price: &#x27;15&#x27;,flag: false&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2、</span></span><br><span class="line"><span class="keyword">let</span> ar =[</span><br><span class="line">	&#123;<span class="attr">price</span>: <span class="string">&#x27;25&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">price</span>: <span class="string">&#x27;15&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">as</span>=ar.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//解构item,且给item添加新的值 flag，键值（flag: false）</span></span><br><span class="line">    <span class="comment">//这里解构相当于把item里面的值都拿出来重新赋值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; ...item, <span class="attr">flag</span>: <span class="literal">false</span> &#125; <span class="comment">//forEach不能return，这句不适合</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(ar,<span class="string">&#x27;ar&#x27;</span>) <span class="comment">// [&#123;price: &#x27;25&#x27;&#125;,&#123;price: &#x27;15&#x27;&#125;] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">as</span>,<span class="string">&#x27;as&#x27;</span>) <span class="comment">// [&#123;price: &#x27;25&#x27;,flag: false&#125;,&#123;price: &#x27;15&#x27;,flag: false&#125;]</span></span><br><span class="line"><span class="comment">// 原数组ar不改变</span></span><br></pre></td></tr></table></figure>
<h3 id="forEach用什么方法结束"><a href="#forEach用什么方法结束" class="headerlink" title="forEach用什么方法结束"></a>forEach用什么方法结束</h3><p>正常终止for循环，我们可以使用break关键字来实现；</p>
<p>forEach循环，不能使用break和continue这两个关键字；</p>
<p>因为这两个关键字要在循环中使用，而forEach中所执行的是callback，callback是个函数所以不能使用；</p>
<p>使用 return 的话，只能跳出本次循环执行下一次循环，并不会终止forEach循环；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运用抛出异常（try catch）：throw new Error(&#x27;error message&#x27;);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.txt.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item.name) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;单课不能为空！&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!item.val) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;上课老师不能为空！&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!item.date) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;上架时间不能为空！&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$message.warning(e.message)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="伪数组-转化为真数组"><a href="#伪数组-转化为真数组" class="headerlink" title="伪数组 转化为真数组"></a>伪数组 转化为真数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//Arguments显示的也有方括号 [1,2,3,4,5...] ，但是后面多了一些其他方法；也有length属性，但没有数组的push，pop等那些方法，像数组又不是数组 ，[[prototype]]可以看到arguments伪数组的原型指向的是Object对象， 真数组的__proto__指向的是Array数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ES6语法 拓展运算符</span></span><br><span class="line">    <span class="keyword">let</span> newArr=[...arguments]</span><br><span class="line">    <span class="comment">//ES6的Array.from</span></span><br><span class="line">    <span class="keyword">let</span> newArr=<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">//利用Array的原型对象的slice方法，配合call()方法修改slice中this指向</span></span><br><span class="line">    <span class="comment">//slice原本是数组的截取子数组的方法，这里给数组的原型对象方法slice的指向强制改成arguments</span></span><br><span class="line">    <span class="keyword">let</span> newArr= <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="扩展符”…”"><a href="#扩展符”…”" class="headerlink" title="扩展符”…”"></a>扩展符”…”</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在对象中的应用</span></span><br><span class="line"><span class="comment">//合并对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3 =&#123;...obj1,...obj2)&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3) <span class="comment">// &#123;a:1,b:2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给对象赋默认值</span></span><br><span class="line"><span class="keyword">var</span> obj_1 = &#123;<span class="attr">a</span>: <span class="number">1</span>,<span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj_2 = &#123;</span><br><span class="line">     ...obj_1,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj_2); &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">3</span>&#125; <span class="comment">//合并的对象中有相同的属性会覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,<span class="attr">age</span>: <span class="number">18</span>,<span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(&#123; ...obj&#125;); <span class="comment">//&#123;name: &#x27;name&#x27;,age: 18,sex: &#x27;男&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title="?? / ?. / || / !! /"></a>?? / ?. / || / !! /</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ?.应用场景,多级嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr_obj = [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;product&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;product&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="string">&#x27;3&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;subitem1&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;subitem&#x27;</span>,</span><br><span class="line">                    <span class="attr">children</span>: [],</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="string">&#x27;4&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;item2&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;item&#x27;</span>,</span><br><span class="line">                    <span class="attr">children</span>: [</span><br><span class="line">                        &#123;<span class="attr">id</span>: <span class="string">&#x27;5&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;subitem3&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;subitem&#x27;</span>,<span class="attr">children</span>: [],&#125;</span><br><span class="line">                    ],</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="string">&#x27;5&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;item3&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;item&#x27;</span>,</span><br><span class="line">                    <span class="attr">children</span>: [</span><br><span class="line">                        &#123;<span class="attr">id</span>: <span class="string">&#x27;6&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;subitem7&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;subitem&#x27;</span>,</span><br><span class="line">                            children[]</span><br><span class="line">                        &#125;, </span><br><span class="line">                    ],</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;<span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;group&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;group&#x27;</span>,</span><br><span class="line">                    <span class="attr">children</span>: [</span><br><span class="line">                        &#123;<span class="attr">id</span>: <span class="string">&#x27;10&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;product1&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;product&#x27;</span>,</span><br><span class="line">                        <span class="attr">children</span>: [</span><br><span class="line">                            &#123;<span class="attr">id</span>: <span class="string">&#x27;11&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;subitem1&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;subitem&#x27;</span>,</span><br><span class="line">                                <span class="attr">children</span>: [],</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;<span class="attr">id</span>: <span class="string">&#x27;12&#x27;</span>,<span class="attr">name</span>: <span class="string">&#x27;item3&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;item&#x27;</span>,</span><br><span class="line">                                <span class="attr">children</span>: [</span><br><span class="line">                                    &#123;<span class="attr">name</span>: <span class="string">&#x27;subitem5&#x27;</span>,<span class="attr">id</span>: <span class="string">&#x27;18&#x27;</span>,<span class="attr">type</span>: <span class="string">&#x27;subitem&#x27;</span>,&#125; </span><br><span class="line">                                ],</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">		<span class="comment">// 现在从上面的数组中，检查每个对象的类型，</span></span><br><span class="line">		<span class="comment">// 如果类型是product或group，添加property disabled true，</span></span><br><span class="line">		<span class="comment">// 如果不是添加property disabled false</span></span><br><span class="line">        <span class="keyword">const</span> handleLoop = <span class="function">(<span class="params">array</span>) =&gt;</span> array.map(<span class="function">(<span class="params">elem</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...elem,</span><br><span class="line">                ...(elem.children &amp;&amp; &#123;<span class="attr">children</span>: handleLoop(elem.children)&#125;), <span class="comment">//递归</span></span><br><span class="line">                <span class="attr">disabled</span>: elem ?.type === <span class="string">&quot;product&quot;</span> || elem ?.type === <span class="string">&quot;group&quot;</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(handleLoop(arr_obj))</span><br></pre></td></tr></table></figure>
<h3 id="数组方法汇总"><a href="#数组方法汇总" class="headerlink" title="数组方法汇总"></a>数组方法汇总</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">map 循环遍历数组、返回一个新的数组</span><br><span class="line"></span><br><span class="line">forEach 循环遍历数组，不改变原数组, forEach不能<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">push/pop 在数组的末尾添加/删除元素  改变原数组</span><br><span class="line"></span><br><span class="line">unshift/ shift 在数组的头部添加/删除元素，改变原数组</span><br><span class="line"></span><br><span class="line">join  把数组转化为字符串</span><br><span class="line"></span><br><span class="line">some  有一项返回为<span class="literal">true</span>，则整体为<span class="literal">true</span>,类似于indexOf 只要数组某个元素符合条件，则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">every  有一项返回为<span class="literal">true</span>，则整体为<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">filter 数组过滤,通常也是跟<span class="keyword">return</span>使用，当回调函数返回 <span class="literal">true</span> 就留下来</span><br><span class="line"></span><br><span class="line">slice(start, end)  数组截取，包括开头，不包括截取，返回一个新的数组</span><br><span class="line"></span><br><span class="line">splice(start, number, value)  删除数组元素，改变原数组</span><br><span class="line"></span><br><span class="line">indexof/lastindexof： 查找数组项，返回对应的下标</span><br><span class="line"></span><br><span class="line">concat：数组的拼接，不影响原数组，浅拷贝</span><br><span class="line"></span><br><span class="line">sort：数组排序 改变原数组</span><br><span class="line"></span><br><span class="line">reverse： 数组反转，改变原数组</span><br></pre></td></tr></table></figure>
<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><p><strong>增</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push()    添加末尾, 并返回新的数组长度。<span class="string">&quot;原数组改变&quot;</span></span><br><span class="line">unshift() 开头添加, 并返回新的数组长度。<span class="string">&quot;原数组改变&quot;</span></span><br><span class="line">concat(arr1,arr2, ...)  合并两个或多个数组，生成一个新的数组。’原数组不变‘</span><br></pre></td></tr></table></figure>
<p><strong>删</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop()   删除并<span class="string">&quot;返回&quot;</span>数组的最后一个元素,若该数组为空，则返回<span class="literal">undefined</span>。<span class="string">&quot;原数组改变&quot;</span></span><br><span class="line">shift() 删除数组的第一项,并<span class="string">&quot;返回&quot;</span>第一个元素的值,若该数组为空，则返回<span class="literal">undefined</span>。<span class="string">&quot;原数组改变&quot;</span></span><br><span class="line">splice() 传入两个参数，分别是开始位置，删除元素的数量，<span class="string">&quot;返回&quot;</span>包含删除元素的数组。 <span class="string">&quot;原数组改变&quot;</span></span><br><span class="line">slice()  按照条件查找出其中的部分内容，’原数组不变‘</span><br></pre></td></tr></table></figure>
<p><strong>改</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">即修改原来数组的内容，常用splice</span><br><span class="line"></span><br><span class="line">传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</span><br></pre></td></tr></table></figure>
<p><strong>查</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">即查找元素，返回元素坐标或者元素值</span><br><span class="line"></span><br><span class="line">indexOf() 返回要查找的元素在数组中的位置，如果没找到则返回 -<span class="number">1</span>,’原数组不变‘</span><br><span class="line">includes() 返回要查找的元素在数组中的位置，找到返回<span class="literal">true</span>，否则<span class="literal">false</span>,’原数组不变‘</span><br><span class="line">find() 返回第一个匹配的元素</span><br></pre></td></tr></table></figure>
<p><strong>分割</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join() 将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号</span><br></pre></td></tr></table></figure>
<p><strong>迭代方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常用来迭代数组的方法（都不改变原数组）有如下：</span><br><span class="line"></span><br><span class="line">some() 对数组中的每一项进行判断，若都不符合则返回<span class="literal">false</span>，否则返回<span class="literal">true</span>，(如果有一项函数返回 <span class="literal">true</span> ，则这个方法返回 <span class="literal">true</span>)</span><br><span class="line">every() 对数组中的每一项进行判断，若都符合则返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">forEach() 用于调用数组的每个元素，并将元素传递给回调函数。’原数组不变‘</span><br><span class="line">filter() 过滤数组中，符合条件的元素并返回一个新的数组</span><br><span class="line">map() 原数组的每一项执行函数后，返回一个新的数组 ’原数组不变‘</span><br></pre></td></tr></table></figure>
<p><strong>reduce</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class="line">语法：</span><br><span class="line">    arr.reduce( <span class="function"><span class="keyword">function</span> (<span class="params"> prev, cur, index, arr </span>)</span>&#123;   </span><br><span class="line">        一系列操作</span><br><span class="line">    &#125;, init);</span><br><span class="line">    <span class="comment">//箭头写法</span></span><br><span class="line">    arr.reduce( <span class="function">(<span class="params"> prev, cur, index, arr </span>) =&gt;</span> &#123;   </span><br><span class="line">        一系列操作</span><br><span class="line">    &#125;, init);</span><br><span class="line"></span><br><span class="line">prev： 必需(初始值, 或者计算结束后的返回值)；</span><br><span class="line">cur： 必需(当前元素)；</span><br><span class="line">index： 可选(当前元素的索引)；</span><br><span class="line">arr：可选(当前元素所属的数组对象)；</span><br><span class="line">init： 可选(传递给函数的初始值)；</span><br><span class="line"></span><br><span class="line">场景一：数组累加、累乘</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y));<span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x*y));<span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line">场景二：计算数组中每个元素出现的次数</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> num = arr2.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur <span class="keyword">in</span> prev)&#123;<span class="comment">//如果prev(初始对象)包含cur(当前元素),数量累加</span></span><br><span class="line">        prev[cur]++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        prev[cur] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;,&#123;&#125;);<span class="comment">//初始值需要设置一个空的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">// &#123;a: 4, b: 3, c: 2, d: 1&#125;</span></span><br><span class="line"></span><br><span class="line">场景三：数组去重</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> remo = arr3.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prev.indexOf(cur)==-<span class="number">1</span>)&#123;<span class="comment">//如果prev没找到cur</span></span><br><span class="line">        <span class="keyword">return</span> prev.concat(cur)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(!prev.includes(cur))&#123;//如果prev不包含cur</span></span><br><span class="line">    <span class="comment">//     return prev.concat(cur)</span></span><br><span class="line">    <span class="comment">// &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//     return prev</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;,[]);<span class="comment">// 初始值设置一个空数组</span></span><br><span class="line"><span class="built_in">console</span>.log(remo);<span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line">场景四：将二维数组转化为一维数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="keyword">let</span> newArr1 = arr4.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> prev.concat(cur)</span><br><span class="line"> &#125;,[])</span><br><span class="line"> <span class="built_in">console</span>.log(newArr1); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">场景五：将多维数组转化为一维数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr5 = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newArr</span>(<span class="params">arr5</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr5.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>prev.concat(<span class="built_in">Array</span>.isArray(cur)?newArr(cur):cur),[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr(arr5)); <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">场景六：求数组中最大的值</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr7 = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> maxNum = arr7.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev,cur);<span class="comment">// Math.max方法可以求出给定参数中最大的数,Math.min方法可以求出给定参数中最小的数</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(maxNum);<span class="comment">// 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序</strong><br>冒泡排序（Bubble Sort） 一种交换排序方法，通过比较两两相邻的元素，按照升序或者降序的规则进行位置的替换，需要使用到双层循环遍历，每遍历一圈只会对对一个数值进行排序，总共需要遍历n-1次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="comment">/* 1. 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换 */</span></span><br><span class="line"><span class="comment">/* 2. 对所有元素均重复以上步骤，直至最后一个元素 */</span></span><br><span class="line"><span class="comment">/* int* a: 排序目标数组; int n: 元素个数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">BubbleSort</span>(<span class="params">int* a, int n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i=<span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;<span class="comment">//n个数比较n-1次,总共比较n-1次</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span> (int j=<span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++)&#123;<span class="comment">//每次比较n-i-1的左右大小判断是否交换</span></span><br><span class="line">		</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])&#123;</span><br><span class="line"></span><br><span class="line">				int temp = a[j];</span><br><span class="line">				a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">				a[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>快速排序</strong><br>通过一趟排序将待排序列以枢轴为标准划分成两部分，使其中一部分记录的关键字均比另一部分小，再分别对这两部分进行快速排序，以达到整个序列有序</p>
<p>第一步：找基准，采用二分的方式，从数组中找一个基数元素(一般就取第一个元素为基数)将一串数据分为两串；</p>
<p>第二步：分区，重新排列数组，将小于基数的元素放左边，大于基数的元素放右边，相同的值放任意位置，使得基数成为中间元素；</p>
<p>第三步：递归，将两个组的元素分别进行排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//一趟快速排序的描述，取一个枢纽,排序好比它小的左边，大的右边，并且返回这个值的指针</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>倒序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse() 将数组倒序。<span class="string">&quot;原数组改变&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>数组排序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort(首元素地址(必填), 尾元素地址的下一个地址(必填), 比较函数(非必填));</span><br><span class="line">如果直接sort（数组名），则从小到大排序（即升序），以下为倒叙</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">30</span>,<span class="number">10</span>,<span class="number">111</span>,<span class="number">35</span>,<span class="number">50</span>,<span class="number">45</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b - a; <span class="comment">//从大到小</span></span><br><span class="line">    <span class="comment">// return a - b; //从小到大</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//输出 [111, 50, 45, 35, 30, 10]</span></span><br></pre></td></tr></table></figure>
<p><strong>数组去重</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）利用ES6 <span class="built_in">Set</span>去重（ES6中最常用）</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）利用<span class="keyword">for</span>嵌套<span class="keyword">for</span>，然后splice去重（ES5中最常用）</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">                    arr.splice(j,<span class="number">1</span>);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）利用indexOf去重</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> array = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array .indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">                array .push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）利用includes</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> array =[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>( !array.includes( arr[i]) ) &#123;<span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">                        array.push(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头写法</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）<span class="keyword">let</span> uniqueOne = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="built_in">console</span>.log(uniqueOne)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="keyword">let</span> uniqueTwo = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">//或者用空对象 let obj = &#123;&#125; 利用对象属性不能重复得特性</span></span><br><span class="line">    <span class="keyword">let</span> brr = []</span><br><span class="line">    arr.forEach( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(item)) &#123; <span class="comment">//如果是对象得话就判断 !obj[item]</span></span><br><span class="line">            map.set(item,<span class="literal">true</span>) <span class="comment">//如果是对象得话就obj[item] =true 其他一样</span></span><br><span class="line">            brr.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> brr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueTwo(arr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="keyword">let</span> uniqueThree = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> brr = []</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用indexOf 返回数组是否包含某个值 没有就返回-1 有就返回下标</span></span><br><span class="line">        <span class="keyword">if</span>(brr.indexOf(item) === -<span class="number">1</span>) brr.push(item)</span><br><span class="line">        <span class="comment">// 或者使用includes 返回数组是否包含某个值 没有就返回false 有就返回true</span></span><br><span class="line">        <span class="keyword">if</span>(!brr.includes(item)) brr.push(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> brr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueThree(arr))</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）<span class="keyword">let</span> uniqueFour = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;                                         </span><br><span class="line">     <span class="comment">// 使用 filter 返回符合条件的集合</span></span><br><span class="line">    <span class="keyword">let</span> brr = arr.filter(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.indexOf(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> brr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFour(arr))</span><br></pre></td></tr></table></figure>
<h3 id="bind、call、apply-区别"><a href="#bind、call、apply-区别" class="headerlink" title="bind、call、apply 区别"></a>bind、call、apply 区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line"><span class="number">1.</span>都是用来改变函数的<span class="built_in">this</span>对象的指向的。</span><br><span class="line"><span class="number">2.</span>第一个参数都是<span class="built_in">this</span>要指向的对象。</span><br><span class="line"><span class="number">3.</span>都可以利用后续参数传参</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line"><span class="number">1.</span>fn.call(obj, arg1, arg2, …),调用一个函数, 第一个参数为要改变的<span class="built_in">this</span>，第二个参数为要传递的参数，参数与方法中是一一对应的。</span><br><span class="line"><span class="number">2.</span>fn.apply(obj, [argsArray]),第一个参数为要改变的<span class="built_in">this</span>，第二个参数为要传递的参数作为一个数组（或类数组对象）提供的参数</span><br><span class="line"><span class="number">3.</span>bind 和call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是bind 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 <span class="built_in">this</span>，之后的一序列参数将会在传递的实参前传入作为它的参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xw = &#123;</span><br><span class="line">        <span class="attr">name</span> : <span class="string">&quot;小王&quot;</span>,</span><br><span class="line">        <span class="attr">gender</span> : <span class="string">&quot;男&quot;</span>,</span><br><span class="line">        <span class="attr">age</span> : <span class="number">24</span>,</span><br><span class="line">        <span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="built_in">this</span>.name + <span class="string">&quot; , &quot;</span> + <span class="built_in">this</span>.gender + <span class="string">&quot; ,今年&quot;</span> + <span class="built_in">this</span>.age);                                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> xh = &#123;</span><br><span class="line">        <span class="attr">name</span> : <span class="string">&quot;小红&quot;</span>,</span><br><span class="line">        <span class="attr">gender</span> : <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        <span class="attr">age</span> : <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    xw.say(); <span class="comment">//小王 ， 男 ， 今年24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何用xw的say方法来显示xh的数据</span></span><br><span class="line">    xw.say.call(xh);</span><br><span class="line"></span><br><span class="line">    xw.say.apply(xh);</span><br><span class="line"></span><br><span class="line">    xw.say.bind(xh)();</span><br><span class="line"><span class="comment">//如果直接写xw.say.bind(xh)是不会有任何结果的,call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------</span></span><br><span class="line">       <span class="keyword">var</span> xw = &#123;</span><br><span class="line">            <span class="attr">name</span> : <span class="string">&quot;小王&quot;</span>,</span><br><span class="line">            <span class="attr">gender</span> : <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            <span class="attr">age</span> : <span class="number">24</span>,</span><br><span class="line">            <span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params">school,grade</span>) </span>&#123;</span><br><span class="line">                    alert(<span class="built_in">this</span>.name + <span class="string">&quot; , &quot;</span> + <span class="built_in">this</span>.gender + <span class="string">&quot; ,今年&quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot; ,在&quot;</span> + school + <span class="string">&quot;上&quot;</span> + grade);                                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> xh = &#123;</span><br><span class="line">            <span class="attr">name</span> : <span class="string">&quot;小红&quot;</span>,</span><br><span class="line">            <span class="attr">gender</span> : <span class="string">&quot;女&quot;</span>,</span><br><span class="line">            <span class="attr">age</span> : <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//可以看到say方法多了两个参数，我们通过call/apply的参数进行传参</span></span><br><span class="line">        xw.say.call(xh,<span class="string">&quot;实验小学&quot;</span>,<span class="string">&quot;六年级&quot;</span>); </span><br><span class="line"></span><br><span class="line">        xw.say.apply(xh,[<span class="string">&quot;实验小学&quot;</span>,<span class="string">&quot;六年级&quot;</span>]);</span><br><span class="line"><span class="comment">//call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应，这就是两者最大的区别</span></span><br><span class="line"><span class="comment">//但是由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参</span></span><br><span class="line">        xw.say.bind(xh)(<span class="string">&quot;实验小学&quot;</span>,<span class="string">&quot;六年级&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="本地存储的方式有哪些？区别及应用场景？"><a href="#本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="本地存储的方式有哪些？区别及应用场景？"></a>本地存储的方式有哪些？区别及应用场景？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaScript本地缓存的方法我们主要讲述以下四种：</span><br><span class="line"></span><br><span class="line">cookie</span><br><span class="line">sessionStorage</span><br><span class="line"><span class="built_in">localStorage</span></span><br><span class="line">indexedDB</span><br><span class="line">区别</span><br><span class="line">关于cookie、sessionStorage、<span class="built_in">localStorage</span>三者的区别主要如下：</span><br><span class="line"></span><br><span class="line">存储大小：cookie数据大小不能超过4k，sessionStorage和<span class="built_in">localStorage</span>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</span><br><span class="line">有效时间：<span class="built_in">localStorage</span>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</span><br><span class="line">数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和<span class="built_in">localStorage</span>不会自动把数据发给服务器，仅在本地保存</span><br><span class="line">应用场景</span><br><span class="line">在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</span><br><span class="line"></span><br><span class="line">标记用户与跟踪用户行为的情况，推荐使用cookie</span><br><span class="line">适合长期保存在本地的数据（令牌），推荐使用<span class="built_in">localStorage</span></span><br><span class="line">敏感账号一次性登录，推荐使用sessionStorage</span><br><span class="line">存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</span><br></pre></td></tr></table></figure>
<h3 id="闭包？闭包使用场景-和-什么是立即执行函数"><a href="#闭包？闭包使用场景-和-什么是立即执行函数" class="headerlink" title="闭包？闭包使用场景 和 什么是立即执行函数?"></a>闭包？闭包使用场景 和 什么是立即执行函数?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">理解: 闭包就是函数中包含另一个函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制收回</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//访问道这个a</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&#x27;hello&#x27;</span>);   <span class="comment">//调用外部的函数</span></span><br><span class="line">fn(<span class="string">&#x27;hello&#x27;</span>)()  <span class="comment">//调用内部函数</span></span><br><span class="line"></span><br><span class="line">闭包: 定义在一个函数内部的函数（方法里面返回方法）。</span><br><span class="line">闭包的使用场景：settimeout、回调、函数防抖、封装私有变量</span><br><span class="line"></span><br><span class="line">过多使用会导致内存泄漏的问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">立即执行函数：声明一个函数，并马上调用这个匿名函数就叫做立即执行函数；</span><br><span class="line">立即执行函数的作用：</span><br><span class="line">	<span class="number">1.</span>不必为函数命名，避免了污染全局变量。</span><br><span class="line">	<span class="number">2.</span>立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</span><br><span class="line">	<span class="number">3.</span>封装变量。</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝浅拷贝的区别？"><a href="#深拷贝浅拷贝的区别？" class="headerlink" title="深拷贝浅拷贝的区别？"></a>深拷贝浅拷贝的区别？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">（理解：b拷贝了a,如果b变了，a跟着变，那就是浅拷贝；b变了，a没变，那就是深拷贝）</span><br><span class="line"></span><br><span class="line">浅拷贝</span><br><span class="line">如果当数组或对象中的值是<span class="string">`基本类型数据`</span>，那拷贝后的数据和原数据是完全没有关联，且互不影响的两个数据，</span><br><span class="line">如果数组或对象的值是<span class="string">`引用类型数据`</span>的话，拷贝后的数组或对象中的引用类型的值跟原数据中的引用类型的值，还是会保持共同的内存地址</span><br><span class="line"></span><br><span class="line">在JavaScript中，存在浅拷贝的现象有：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、<span class="built_in">Object</span>.assign</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---当对象为基本类型数据</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">	<span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>，</span><br><span class="line">	<span class="attr">age</span>: <span class="string">&#x27;14&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.age = <span class="string">&#x27;23&#x27;</span>;</span><br><span class="line">obj2.sex = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; sex: &#x27;男&#x27;, age: &#x27;14&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123; sex: &#x27;女&#x27;, age: &#x27;23&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---当对象引用类型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;</span><br><span class="line">	<span class="attr">person</span>: &#123;<span class="attr">name</span>: <span class="string">&quot;完美&quot;</span>&#125;,</span><br><span class="line">	<span class="attr">age</span>: <span class="string">&#x27;14&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj3);</span><br><span class="line">obj4.person.name = <span class="string">&quot;哈哈哈&quot;</span>;</span><br><span class="line">obj4.age = <span class="string">&#x27;23&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">// &#123; person: &#123; name: &#x27;哈哈哈&#x27;&#125;, age: &#x27;14&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// &#123; person: &#123; name: &#x27;哈哈哈&#x27;&#125;, age: &#x27;23&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="built_in">Array</span>.prototype.slice()</span><br><span class="line"></span><br><span class="line"><span class="comment">//---当数组基本类型数据</span></span><br><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1.slice();  	</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a1);<span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);<span class="comment">// [3, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---当数组有引用类型数据</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;完美&#x27;</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">&#x27;哈哈哈哈&#x27;</span>;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 1, 2, &#123; name: &#x27;哈哈哈哈&#x27; &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[ 3, 2, &#123; name: &#x27;哈哈哈哈&#x27; &#125; ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="built_in">Array</span>.prototype.concat()</span><br><span class="line"></span><br><span class="line"><span class="comment">//---当数组为基本类型数据</span></span><br><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1.concat();  	</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a1);<span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);<span class="comment">// [3, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---当数组中有引用类型数据</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;完美&#x27;</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">&#x27;哈哈哈哈&#x27;</span>;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 1, 2, &#123; name: &#x27;哈哈哈哈&#x27; &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[ 3, 2, &#123; name: &#x27;哈哈哈哈&#x27; &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、扩展运算符(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//---当对象为基本类型数据</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;FungLeo&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;man&#x27;</span>, <span class="attr">old</span>: <span class="string">&#x27;18&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; ...obj2 &#125; = obj</span><br><span class="line">obj.old = <span class="string">&#x27;22&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;FungLeo&#x27;, sex: &#x27;man&#x27;, old: &#x27;18&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">// &#123; name: &#x27;FungLeo&#x27;, sex: &#x27;man&#x27;, old: &#x27;22&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---当对象中有引用类型数据</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;FungLeo&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;man&#x27;</span>, <span class="attr">old</span>: <span class="string">&#x27;18&#x27;</span>,<span class="attr">id</span>:&#123;<span class="attr">idx</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; ...obj2 &#125; = obj</span><br><span class="line">obj.old = <span class="string">&#x27;22&#x27;</span></span><br><span class="line">obj.id.idx = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;FungLeo&#x27;, sex: &#x27;man&#x27;, old: &#x27;18&#x27;,id:&#123;idx: 0&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">// &#123; name: &#x27;FungLeo&#x27;, sex: &#x27;man&#x27;, old: &#x27;22&#x27;,id:&#123;idx: 0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">深拷贝，就是不管原数据中值是什么类型的数据，拷贝后的新数据跟原数据是完全没有关联的</span><br><span class="line"></span><br><span class="line">常见的深拷贝方式有：</span><br><span class="line"></span><br><span class="line"><span class="comment">//万能转换器JSON.parse(JSON.stringify(obj)) 深拷贝已对象，它可以`深拷贝多层级的，不同担心嵌套问题`。</span></span><br><span class="line"><span class="number">1</span>、<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify())，<span class="comment">//这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</span></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;gg&#x27;</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( arr ));</span><br><span class="line">arr1[<span class="number">2</span>].name = <span class="string">&#x27;hh&#x27;</span>;</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//[1,2 &#123;name: &#x27;gg&#x27;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">//[5,2 &#123;name: &#x27;hh&#x27;&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、jQuery.extend()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意要引入jQuery</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">father</span>: &#123; <span class="attr">age</span>: <span class="number">45</span>&#125;,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = $.extend(<span class="literal">true</span>, &#123;&#125;, obj1)</span><br><span class="line">obj2.name = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">obj2.father.age = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1,obj1.fn(<span class="number">9</span>)) <span class="comment">// &#123;name: &quot;张三&quot;,age: 18,father: &#123; age: 45&#125;,fn:f()&#125;,9</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2,obj2.fn(<span class="number">99</span>)) <span class="comment">// &#123;name: &quot;李四&quot;,age: 18,father: &#123; age: 50&#125;,fn:f()&#125;,99</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、利用递归遍历对象或数组</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(source)===<span class="string">&#x27;[object Object]&#x27;</span>)&#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(source)===<span class="string">&#x27;[object Array]&#x27;</span>)&#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> source)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(source[attr])===<span class="string">&#x27;[object Array]&#x27;</span> || <span class="built_in">Object</span>.prototype.toString.call(source[attr])===<span class="string">&#x27;[object Object]&#x27;</span>)&#123;</span><br><span class="line">            result[attr] = clone(source[attr])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[attr] = source[attr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">12</span>,</span><br><span class="line">    <span class="attr">wife</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;翠花&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">11</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">var</span> res = clone(arr);</span><br><span class="line">res[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">res[<span class="number">2</span>].name = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">res[<span class="number">2</span>].wife.name = <span class="string">&#x27;赵五&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr,arr[<span class="number">2</span>].fn(<span class="number">9</span>)); <span class="comment">// [1,2,&#123;name:&quot;张三&quot;,age:12,wife:&#123;name:&quot;翠花&quot;,age:11&#125;&#125;],9</span></span><br><span class="line"><span class="built_in">console</span>.log(res,res[<span class="number">2</span>].fn(<span class="number">99</span>)); <span class="comment">// [5,2,&#123;name:&quot;李四&quot;,age:12,wife:&#123;name:&quot;赵五&quot;,age:11&#125;&#125;],99</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_.cloneDeep()   <span class="comment">//函数库lodash,该函数库也有提供_.cloneDeep用来做深拷贝</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript中的数据类型"><a href="#JavaScript中的数据类型" class="headerlink" title="JavaScript中的数据类型"></a>JavaScript中的数据类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string、number、<span class="built_in">Boolean</span>、<span class="literal">undefined</span>、<span class="literal">null</span>、object、<span class="built_in">Array</span>、<span class="built_in">Symbol</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">理解: 电梯第一个人进来后，等待<span class="number">15</span>秒。如果过程中又有人进来，<span class="number">15</span>秒等待重新计时，直到<span class="number">15</span>秒后开始运送，这是防抖</span><br><span class="line"></span><br><span class="line">      在游戏回城的时候被打断，再次点回城就会重新计时，最终只有没被打断的最后一次，才能成功回城，就是防抖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      电梯第一个人进来后，<span class="number">15</span>秒后准时运送一次，这是节流</span><br><span class="line">      </span><br><span class="line">      鼠标点击下一张轮播图，不管单位时间内连续点击了多少次，轮播图都是<span class="number">2</span>秒换下一张，就是节流</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时(在单位时间内频繁触发事件，只有最后一次生效)</span><br><span class="line">   </span><br><span class="line">   应用场景: 文本输入的验证；</span><br><span class="line">   <span class="string">`&lt;input type=&quot;text&quot; id=&#x27;debounce&#x27; onInput=&#x27;debounceInput(event)&#x27; &gt;`</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个定时器，保存上一次的定时器</span></span><br><span class="line">        <span class="keyword">let</span> time = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// let args = arguments;</span></span><br><span class="line">            <span class="comment">//取消上一次定时器</span></span><br><span class="line">            <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//延迟执行</span></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//外部传入的真正要执行的函数</span></span><br><span class="line">                fn.apply(<span class="built_in">this</span>, args); </span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//input事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onInput</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        val = e.target.value</span><br><span class="line">        <span class="keyword">if</span>(val)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;有防抖&#x27;</span>,val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    <span class="keyword">const</span> debounceInput = debounce(onInput, <span class="number">300</span>)  </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效(在单位时间内频繁触发事件，只生效一次（也就是只有第一次生效）)</span><br><span class="line">   </span><br><span class="line">   应用场景：滚动加载，加载更多或滚到底部监听。</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 尾节流，定时器实现，不会立即执行，而是在delay之后执行</span></span><br><span class="line">    <span class="comment">// 最后停止触发之后，还会执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">..args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// let args = arguments;</span></span><br><span class="line">            <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">                timer = <span class="literal">null</span>; <span class="comment">// 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  定时器不用箭头函数时this要改变一下</span></span><br><span class="line">            <span class="comment">// let _this = this;</span></span><br><span class="line">            <span class="comment">// //let args = arguments;</span></span><br><span class="line">            <span class="comment">// if (timer) &#123;</span></span><br><span class="line">            <span class="comment">//     return;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// timer = setTimeout(function () &#123;</span></span><br><span class="line">            <span class="comment">//     fn.apply(_this, args);</span></span><br><span class="line">            <span class="comment">//     timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span></span><br><span class="line">            <span class="comment">// &#125;, delay)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 尾节流，定时器实现，不会立即执行，而是在delay之后执行</span></span><br><span class="line">    <span class="comment">// 最后停止触发之后，还会执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">..args</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// let args = arguments;</span></span><br><span class="line">            <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">                timer = <span class="literal">null</span>; <span class="comment">// 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  定时器不用箭头函数时this要改变一下</span></span><br><span class="line">            <span class="comment">// let _this = this;</span></span><br><span class="line">            <span class="comment">// //let args = arguments;</span></span><br><span class="line">            <span class="comment">// if (timer) &#123;</span></span><br><span class="line">            <span class="comment">//     return;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// timer = setTimeout(function () &#123;</span></span><br><span class="line">            <span class="comment">//     fn.apply(_this, args);</span></span><br><span class="line">            <span class="comment">//     timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span></span><br><span class="line">            <span class="comment">// &#125;, delay)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    <span class="keyword">const</span> throttleHandler = throttle(handle, <span class="number">3000</span>)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttleHandler)</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>). 箭头函数更加简洁；</span><br><span class="line">(<span class="number">2</span>). 箭头函数不会创建自己的<span class="built_in">this</span>，所以它没有自己的<span class="built_in">this</span>，它只会在自己作用域的上一层继承<span class="built_in">this</span>，所以箭头函数中的<span class="built_in">this</span>指向在它定义时就确认了，之后不会再改变，所以箭头函数的<span class="built_in">this</span>值永远不会改变；</span><br><span class="line">(<span class="number">3</span>). call()、apply()、bind()等方法不能改变箭头函数<span class="built_in">this</span>的的指向；</span><br><span class="line">(<span class="number">4</span>). 箭头函数不能作为构造函数使用；</span><br><span class="line">(<span class="number">5</span>). 箭头函数没有自己的<span class="built_in">arguments</span>；</span><br><span class="line">(<span class="number">6</span>). 箭头函数没有prototype(原型)，原型是<span class="literal">undefined</span>；</span><br></pre></td></tr></table></figure>
<h3 id="你是怎么理解面向对象的，什么是面向对象，用面向对象做过什么"><a href="#你是怎么理解面向对象的，什么是面向对象，用面向对象做过什么" class="headerlink" title="你是怎么理解面向对象的，什么是面向对象，用面向对象做过什么"></a>你是怎么理解面向对象的，什么是面向对象，用面向对象做过什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">面向对象的三大特性：</span><br><span class="line"></span><br><span class="line">封装</span><br><span class="line">隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</span><br><span class="line"></span><br><span class="line">继承</span><br><span class="line">提高代码复用性；继承是多态的前提。</span><br><span class="line"></span><br><span class="line">多态</span><br><span class="line">父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</span><br><span class="line"></span><br><span class="line">为什么要用面向对象？</span><br><span class="line"> 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</span><br></pre></td></tr></table></figure>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">面向对象以对象为中心。先把要完成的功能封装成一个一个的对象，通过调用对象的方法或属性来完成功能</span><br><span class="line"></span><br><span class="line">优点：不仅关注眼前的事件实现，也关注未来可能发生的事件。具有高度的拓展性和复用性，特点是继承、封装、多肽</span><br><span class="line"></span><br><span class="line">缺点：如果只是单一的功能实现，面向对象的设计思路会过于繁琐</span><br><span class="line"></span><br><span class="line">面向过程是以事件为中心，按照我们编写的代码是根据完成一个步骤的过程来进行</span><br><span class="line"></span><br><span class="line">优点：根据事情的目的分解出过程，再一步步实施。对于不复杂的事件执行效率快</span><br><span class="line"></span><br><span class="line">缺点：只关注眼前事件的实现</span><br></pre></td></tr></table></figure>
<h3 id="如何解决数字精度丢失的问题"><a href="#如何解决数字精度丢失的问题" class="headerlink" title="如何解决数字精度丢失的问题?"></a>如何解决数字精度丢失的问题?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</span><br><span class="line"></span><br><span class="line">当你拿到 <span class="number">1.4000000000000001</span> 这样的数据要展示时，建议使用 toPrecision 凑整并 <span class="built_in">parseFloat</span> 转成数字后再显示，如下：</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1.4000000000000001</span>.toPrecision(<span class="number">12</span>)) === <span class="number">1.4</span>  <span class="comment">// True</span></span><br><span class="line">封装成方法就是：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。</span><br><span class="line"></span><br><span class="line">主要思想是：将小数先转换成拆分两个字符串，然后计算小数部分的字符串的长度，然后利用这个长度将小数变成整数！</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 精确加法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> num1Digits = (num1.toString().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).length;</span><br><span class="line">  <span class="keyword">const</span> num2Digits = (num2.toString().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span>).length;</span><br><span class="line">  <span class="keyword">const</span> baseNum = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(num1Digits, num2Digits));</span><br><span class="line">  <span class="keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum;</span><br><span class="line">&#125;</span><br><span class="line">最后还可以使用第三方库，如<span class="built_in">Math</span>.js、BigDecimal.js</span><br></pre></td></tr></table></figure>
<p>其他 +-*/ 详见   <a href="/2017/05/25/js/%E8%A7%A3%E5%86%B3%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/" title="解决数字精度丢失">解决数字精度丢失</a></p>
<h3 id="JavaScript-中内存泄漏的几种情况？"><a href="#JavaScript-中内存泄漏的几种情况？" class="headerlink" title="JavaScript 中内存泄漏的几种情况？"></a>JavaScript 中内存泄漏的几种情况？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 意外的全局变量：由于使用未声明的变量,而意外的创建了一个全局变量,而使这个变量一直留在内存中无法被回收</span><br><span class="line">(<span class="number">2</span>) 被遗忘的计时器或回调函数：设置了 <span class="built_in">setInterval</span> 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line">(<span class="number">3</span>) 脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line">(<span class="number">4</span>) 闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中</span><br></pre></td></tr></table></figure>
<h3 id="TypeScript-和JavaScript有什么区别"><a href="#TypeScript-和JavaScript有什么区别" class="headerlink" title="TypeScript 和JavaScript有什么区别"></a>TypeScript 和JavaScript有什么区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts是js的超集，是js的扩展语言，结合ide可以让我们再开发过程中知道变量的类型并提供联想提示</span><br></pre></td></tr></table></figure>
<h3 id="JS中的三种事件模型是什么？"><a href="#JS中的三种事件模型是什么？" class="headerlink" title="JS中的三种事件模型是什么？"></a>JS中的三种事件模型是什么？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">原始模型(DOM0) </span><br><span class="line">    只支持冒泡，不支持捕获</span><br><span class="line">    同一类型的事件只能绑定一次</span><br><span class="line">        绑定监听函数</span><br><span class="line">        HTML代码中直接绑定</span><br><span class="line">        &lt;input type=<span class="string">&quot;button&quot;</span>  οnclick=<span class="string">&quot;fun()&quot;</span>&gt;</span><br><span class="line">        通过js代码绑定</span><br><span class="line">        <span class="keyword">var</span> btn  = <span class="built_in">document</span>.getElementById(<span class="string">&quot;.btn&quot;</span>);</span><br><span class="line">        btn.onclick = fun;</span><br><span class="line">IE模型(基本不用) </span><br><span class="line">    事件处理阶段</span><br><span class="line">    事件冒泡阶段</span><br><span class="line">        事件绑定监听函数</span><br><span class="line">        attachEvent()</span><br><span class="line">        detachEvent()</span><br><span class="line"></span><br><span class="line">标准模型(dom2模型)</span><br><span class="line">    事件捕获阶段</span><br><span class="line">    事件处理阶段</span><br><span class="line">    事件冒泡阶段</span><br><span class="line"></span><br><span class="line">        事件绑定监听函数</span><br><span class="line">        addEventListener()</span><br><span class="line">        removeEventListener()</span><br></pre></td></tr></table></figure>
<h3 id="ES6声明变量的六种方法-1"><a href="#ES6声明变量的六种方法-1" class="headerlink" title="ES6声明变量的六种方法"></a>ES6声明变量的六种方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ES5: <span class="keyword">var</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"><span class="title">ES6</span>: <span class="title">let</span> <span class="title">const</span> <span class="title">import</span> <span class="title">class</span>(<span class="params"><span class="keyword">class</span>类</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="JS实现继承的方式有哪些？-1"><a href="#JS实现继承的方式有哪些？-1" class="headerlink" title="JS实现继承的方式有哪些？"></a>JS实现继承的方式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数继承 原型链继承 组合继承 寄生组合继承 ES6类(<span class="class"><span class="keyword">class</span>类)继承</span></span><br></pre></td></tr></table></figure>
<h3 id="原型，原型链"><a href="#原型，原型链" class="headerlink" title="原型，原型链 ?"></a>原型，原型链 ?</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">先了解构造函数</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">        <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="built_in">this</span>.name) &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Zaxlct&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Software Engineer&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Mick&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Doctor&#x27;</span>);</span><br><span class="line"></span><br><span class="line">上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 <span class="title">constructor</span> （构造函数）属性，该属性（是一个指针）指向 <span class="title">Person</span>  即：</span><br><span class="line">  <span class="title">console</span>.<span class="title">log</span>(<span class="params">person1.constructor == Person</span>); <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">我们要记住两个概念（构造函数，实例）：</span><br><span class="line">person1 和 person2 都是 构造函数 Person 的实例</span><br><span class="line">一个公式： 实例的构造函数属性（<span class="title">constructor</span>）指向构造函数</span><br><span class="line"></span><br><span class="line">1、原型 <span class="title">prototype</span></span><br><span class="line">常规的数组 [ ] 和对象 &#123; &#125; 是没有原型的，原型是函数<span class="function"><span class="keyword">function</span>特有的；</span></span><br><span class="line"><span class="function">每一个函数都会有<span class="title">prototype</span>属性,被称为显式原型；</span></span><br><span class="line"><span class="function">每一个实例对象都会有<span class="title">__proto__</span>属性,其被称为隐式原型</span></span><br><span class="line"><span class="function">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">stu</span> = <span class="title">new</span> <span class="title">Student</span>(<span class="params"></span>)</span>;</span><br><span class="line">    Student.prototype.name = <span class="string">&#x27;Jerry&#x27;</span>;<span class="comment">/*如果prototype中  有这个属性，在这个语句后也会生成相应属性*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(stu.name);<span class="comment">/*输出Jerry*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(stu.__proto__ === Student.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">同样的，不仅仅是属性，方法也是可以继承的</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line">    Student.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    stu.sayHello();<span class="comment">/*调用方法后输出hello*/</span></span><br><span class="line"></span><br><span class="line">但是如果当我们在构造函数中拥有和原型一样的属性或者方法的时候，会优先使用构造函数的属性和方法</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;hello I&#x27;m&quot;</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line">    Student.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    stu.sayHello();<span class="comment">/*调用sayHello方法*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(stu.name);<span class="comment">/*输出名字*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="comment">//hello I&#x27;m Tom</span></span><br><span class="line">    <span class="comment">//Tom</span></span><br><span class="line"></span><br><span class="line">利用原型的这个特征，我们就可以把一些对象的共有属性提取出来</span><br><span class="line"></span><br><span class="line">    Student.prototype = &#123;</span><br><span class="line">        <span class="attr">school</span> : <span class="string">&#x27;清华大学&#x27;</span>,</span><br><span class="line">        <span class="attr">country</span> : <span class="string">&#x27;中国&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stu1.school, stu1.country, stu1.name, stu1.age, stu1.sex);<span class="comment">//清华大学 中国 Tom 18 male</span></span><br><span class="line">    <span class="built_in">console</span>.log(stu2.school, stu2.country, stu2.name, stu2.age, stu2.sex);<span class="comment">//清华大学 中国 Jerry 20 female</span></span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span></span><br><span class="line">  在原型的使用中，我们还会遇到一个属性，<span class="title">constructor</span>，它是用于查看对象的构造器的属性，并且这个属性也是系统自带的，我们也可以对其进行修改：</span><br><span class="line">    <span class="title">function</span> <span class="title">Student</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="built_in">console</span>.log(stu.constructor); <span class="comment">//Student()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.constructor = <span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(stu.constructor);<span class="comment">//Teacher()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、原型链</span><br><span class="line">原型链可以理解成一个构造器连接着上一层的实例，上一层的实例接着往上连接，以此类推，就形成了原型链，具体的示例如下</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Grand</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getGrand = <span class="string">&#x27;grand&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> grand = <span class="keyword">new</span> Grand();</span><br><span class="line">    Father.prototype = grand;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getFather = <span class="string">&#x27;father&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line">    Son.prototype = father;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getSon = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="comment">//console.log(son.getSon) //son</span></span><br><span class="line">    <span class="comment">//console.log(son.getFather) //father</span></span><br><span class="line">    <span class="comment">//console.log(son.getGrand) //grand</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//console.log(father.getSon) //undefined</span></span><br><span class="line">    <span class="comment">//console.log(father.getFather) //father</span></span><br><span class="line">    <span class="comment">//console.log(father.getGrand) //grand</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//console.log(grand.getSon) //undefined</span></span><br><span class="line">    <span class="comment">//console.log(grand.getFather) //undefined</span></span><br><span class="line">    <span class="comment">//console.log(grand.getGrand) //grand</span></span><br><span class="line">上述代码，就是形成了一条原型链，</span><br><span class="line">Son的原型是已经实例化的father对象，Father的原型是已经实例化的grand对象，</span><br><span class="line">那么实例化的son就可以调用Grand构造器和Father构造器中的属性，</span><br><span class="line">而相反地，实例化的father就无法调用Son构造器中的方法或属性，实例化的grand同理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、作用域就是变量与函数的可访问范围</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、一般情况下，变量取值到创建这个变量的函数的作用域中取值。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>与<span class="keyword">instanceof</span>都是判断数据类型的方法，区别如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>会返回一个变量的基本类型，<span class="keyword">instanceof</span>返回的是一个布尔值</span><br><span class="line"><span class="keyword">instanceof</span> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</span><br><span class="line">而<span class="keyword">typeof</span> 也存在弊端，它虽然可以判断基础数据类型（<span class="literal">null</span> 除外），但是引用数据类型中，除了<span class="function"><span class="keyword">function</span> 类型以外，其他的也无法判断</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h3 id="ajax、axios、jsonp的理解"><a href="#ajax、axios、jsonp的理解" class="headerlink" title="ajax、axios、jsonp的理解"></a>ajax、axios、jsonp的理解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、jsonp是一种可以解决跨域问题的方式，就是通过动态创建script标签用src引入外部文件实现跨域，script加载实际上就是一个get请求，并不能实现post请求。(其他实现跨域的方法有：iframe,<span class="built_in">window</span>.name,postMessage,CORS...)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ajax是一种技术，ajax技术包含了get和post请求的，但是它仅仅是一种获取数据的技术，不能直接实现跨域，只有后台服务器配置好Access-Control-Allow-Origin，才可以实现请求的跨域。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、axios是通过promise实现对ajax技术的一种封装，axios是ajax，ajax不止axios。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">juery的$.ajax实现get请求能跨域是因为jsonp或者因为原生ajax和服务器的配合，post请求能跨域就只能是因为原生ajax和服务器的配合</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ajax的请求过程"><a href="#ajax的请求过程" class="headerlink" title="ajax的请求过程"></a>ajax的请求过程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax 提交 post 请求的数据</span></span><br><span class="line"><span class="comment">// 1. 创建核心对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 2. 准备建立连接</span></span><br><span class="line">xhr.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;register.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 3. 发送请求</span></span><br><span class="line"><span class="comment">// 如果要POST提交数据，则需要设置请求头</span></span><br><span class="line"><span class="comment">// 有的面试官会问为什么要设置请求头？ 知道请求正文是以什么格式</span></span><br><span class="line"><span class="comment">// Content-Type: application/x-www-form-urlencoded，请求正文是类似 get 请求 url 的请求参数</span></span><br><span class="line"><span class="comment">// Content-Type: application/json，请求正文是一个 json 格式的字符串</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">xhr.send(querystring);</span><br><span class="line"><span class="comment">// 4. 处理响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123; <span class="comment">// 请求处理完毕，响应就绪</span></span><br><span class="line">          <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123; <span class="comment">// 请求成功</span></span><br><span class="line">               <span class="keyword">var</span> data = xhr.responseText;</span><br><span class="line">               <span class="built_in">console</span>.log(data);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ajax请求的时候get-和post方式的区别"><a href="#ajax请求的时候get-和post方式的区别" class="headerlink" title="ajax请求的时候get 和post方式的区别"></a>ajax请求的时候get 和post方式的区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、get请求不安全，post安全 ；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、get请求数据有大小限制，post无限制 ；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、get请求参数会在url中显示，容易被他人窃取，post在请求体中，不会被窃取；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、post需要设置请求头。</span><br></pre></td></tr></table></figure>
<h3 id="什么是事件委托以及优缺点"><a href="#什么是事件委托以及优缺点" class="headerlink" title="什么是事件委托以及优缺点"></a>什么是事件委托以及优缺点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js事件委托就是利用冒泡的原理，把本应该添加到某个元素上的事件委托给他的父级，从而减少DOM交互达到网页优化。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。 <span class="number">2.</span>可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DOM操作与BOM操作"><a href="#DOM操作与BOM操作" class="headerlink" title="DOM操作与BOM操作"></a>DOM操作与BOM操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) DOM操作</span><br><span class="line">例如：<span class="built_in">document</span>.getElementById 就是dom操作</span><br><span class="line">DOM事件模型和事件流</span><br><span class="line">DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</span><br><span class="line">（<span class="number">1</span>）捕获阶段：事件从<span class="built_in">window</span>对象自上而下向目标节点传播的阶段；</span><br><span class="line">（<span class="number">2</span>）目标阶段：真正的目标节点正在处理事件的阶段；</span><br><span class="line">（<span class="number">3</span>）冒泡阶段：事件从目标节点自下而上向<span class="built_in">window</span>对象传播的阶段。</span><br><span class="line">如何阻止冒泡？</span><br><span class="line">通过 event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。</span><br><span class="line"></span><br><span class="line">事件代理(事件委托)</span><br><span class="line">由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</span><br><span class="line">事件代理优点：</span><br><span class="line">使代码简洁；减少浏览器的内存占用；</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) BOM操作</span><br><span class="line">BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</span><br><span class="line">例如：<span class="built_in">window</span>.screen对象：包含有关用户屏幕的信息</span><br><span class="line"><span class="built_in">window</span>.location对象：用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面</span><br><span class="line"><span class="built_in">window</span>.history对象：浏览历史的前进后退等</span><br><span class="line"><span class="built_in">window</span>.navigator对象：常常用来获取浏览器信息、是否移动端访问等等</span><br></pre></td></tr></table></figure>

<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">什么是跨域？</span><br><span class="line">当协议、子域名、主域名、端口号中任意一个不相同时都算做不同域，不同域之间相互请求资源，就算作“跨域”。</span><br><span class="line"></span><br><span class="line">常见的几种跨域解决方案</span><br><span class="line">JSONP：利用同源策略对 script 标签不受限制,不过只支持GET请求</span><br><span class="line">    为什么jsonp只支持get请求?</span><br><span class="line">        如果看过 JSONP 库的源码就知道，常见的实现代码其实就是 <span class="built_in">document</span>.createElement(‘script’) 生成一个 script 标签，然后插 body 里而已。在这里根本没有设置请求格式的余地。</span><br><span class="line"></span><br><span class="line">        所以JSONP的实现原理就是创建一个script标签, 再把需要请求的api地址放到src里. 这个请求只能用GET方法, 不可能是POST</span><br><span class="line"></span><br><span class="line">CORS：实现 CORS 通信的关键是后端，服务端设置 Access-Control-Allow-Origin 就可以开启，备受推崇的跨域解决方案，比 JSONP 简单许多</span><br><span class="line"></span><br><span class="line">Node中间件代理或nginx反向代理：主要是通过同源策略对服务器不加限制</span><br><span class="line"></span><br><span class="line">vue-cli代理跨域：devServer</span><br></pre></td></tr></table></figure>

<h3 id="前端vue解决跨域"><a href="#前端vue解决跨域" class="headerlink" title="前端vue解决跨域"></a>前端vue解决跨域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">VUE2<span class="number">.0</span>中常用proxy来解决跨域问题</span><br><span class="line">    步骤<span class="number">1</span>、在项目config目录下面有个index文件中设置如下代码片段</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        <span class="attr">dev</span>: &#123;</span><br><span class="line">            <span class="comment">// Paths</span></span><br><span class="line">            <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">            <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">proxyTable</span>: &#123; <span class="comment">// 配置跨域</span></span><br><span class="line">                <span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">                    <span class="attr">target</span>:<span class="string">`http://www.baidu.com`</span>, <span class="comment">//请求后台接口</span></span><br><span class="line">                    <span class="attr">changeOrigin</span>:<span class="literal">true</span>, <span class="comment">// 是否允许跨域</span></span><br><span class="line">                    <span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">                        <span class="string">&#x27;^/api&#x27;</span> : <span class="string">&#x27;/api&#x27;</span> <span class="comment">// 重写请求，//重写路径 比如&#x27;/api/aaa/ccc&#x27;重写为&#x27;/aaa/ccc&#x27;</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    步骤<span class="number">2</span>、创建axioss实例时，将baseUrl设置为 ‘/api’</span><br><span class="line">    <span class="keyword">const</span> http = axios.create(&#123;</span><br><span class="line">        <span class="attr">timeout</span>: <span class="number">1000</span> * <span class="number">1000000</span>,</span><br><span class="line">        <span class="attr">withCredentials</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">BASE_URL</span>: <span class="string">&#x27;/api&#x27;</span></span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=utf-8&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Set-和-Map有什么区别"><a href="#Set-和-Map有什么区别" class="headerlink" title="Set 和 Map有什么区别"></a>Set 和 Map有什么区别</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="built_in">Map</span>是键值对，<span class="built_in">Set</span>是值得合集，当然键和值可以是任何的值；</span><br><span class="line">(<span class="number">2</span>) <span class="built_in">Map</span>可以通过get方法获取，而set不能因为它只有值；</span><br><span class="line">(<span class="number">3</span>) 都能通过迭代器进行<span class="keyword">for</span>…<span class="keyword">of</span>遍历；</span><br><span class="line">(<span class="number">4</span>) <span class="built_in">Set</span>的值是唯一的可以做数组去重，而<span class="built_in">Map</span>由于没有格式限制，可以做数据存储</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> 和 <span class="built_in">Set</span> 数据结构它们都是以构造函数的形式出现的，所以我们通常使用 <span class="keyword">new</span> <span class="built_in">Set</span>()或者 <span class="keyword">new</span> <span class="built_in">Map</span>()的形式初始化的</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>（字典）</span><br><span class="line">    初始化 map 对象</span><br><span class="line">    <span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    初始化 map 时传入数据（默认接收一个二维数组）</span><br><span class="line">    <span class="keyword">let</span> defaultMap = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>]]); <span class="comment">//打印 &#123;&#x27;name&#x27; =&gt; &#x27;张三&#x27;, &#x27;age&#x27; =&gt; 20&#125;</span></span><br><span class="line"></span><br><span class="line">    插入数据</span><br><span class="line">    myMap.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小猪课堂&#x27;</span>); <span class="comment">// 字符串作为键</span></span><br><span class="line">    myMap.set(<span class="number">12</span>, <span class="string">&#x27;会飞的猪&#x27;</span>); <span class="comment">// number 类型作为键</span></span><br><span class="line">    myMap.set(&#123;&#125;, <span class="string">&#x27;知乎&#x27;</span>); <span class="comment">// 对象类型作为键</span></span><br><span class="line"></span><br><span class="line">    获取长度</span><br><span class="line">    <span class="keyword">let</span> myMapSize = myMap.size;</span><br><span class="line"></span><br><span class="line">    获取值</span><br><span class="line">    <span class="keyword">let</span> objKey = &#123;&#125;;</span><br><span class="line">    myMap.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小猪课堂&#x27;</span>); <span class="comment">// 字符串作为键</span></span><br><span class="line">    myMap.set(<span class="number">12</span>, <span class="string">&#x27;会飞的猪&#x27;</span>); <span class="comment">// number 类型作为键</span></span><br><span class="line">    myMap.set(objKey, <span class="string">&#x27;知乎&#x27;</span>); <span class="comment">// 对象类型作为键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name = myMap.get(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> age = myMap.get(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">let</span> any = myMap.get(objKey);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(name, age, any); <span class="comment">// 小猪课堂 会飞的猪 知乎</span></span><br><span class="line">    上段代码中需要注意的是不能使用 myMap.get(&#123;&#125;)的形式获取数据，因为 objKey!==&#123;&#125;。</span><br><span class="line"></span><br><span class="line">    删除某个值</span><br><span class="line">    myMap.delete(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    判断某个值是否存在</span><br><span class="line">    myMap.has(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 返回 bool 值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>（集合）</span><br><span class="line"></span><br><span class="line">    初始化<span class="built_in">Set</span>对</span><br><span class="line">    <span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    初始化<span class="built_in">Set</span>对象带有默认值：（和<span class="built_in">Map</span>类似，<span class="built_in">Set</span>初始化时也可以初始化默认数据。）</span><br><span class="line">    <span class="keyword">let</span> defaultSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;张三&#x27;</span>, <span class="number">12</span>, <span class="literal">true</span>]); <span class="comment">//打印 &#123;&#x27;张三&#x27;, 12, true&#125;</span></span><br><span class="line"></span><br><span class="line">    插入数据</span><br><span class="line">    mySet.add(<span class="number">1</span>);</span><br><span class="line">    mySet.add(<span class="string">&#x27;小猪课堂&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    获取长度</span><br><span class="line">    <span class="keyword">let</span> mySetSize = mySet.size;</span><br><span class="line"></span><br><span class="line">    获取值(由于<span class="built_in">Set</span>对象存储的不是键值对形式，所以未提供get方法获取值，我们通常遍历它获取值)</span><br><span class="line">    mySet.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    删除某个值</span><br><span class="line">    mySet.delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    判断某个值是否存在</span><br><span class="line">    mySet.has(<span class="number">1</span>); <span class="comment">// 返回Boolean值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Map与对象的互换</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(obj)</span><br><span class="line">    <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="常见的检测数据类型的几种方式"><a href="#常见的检测数据类型的几种方式" class="headerlink" title="常见的检测数据类型的几种方式"></a>常见的检测数据类型的几种方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="keyword">typeof</span> 其中数组、对象、<span class="literal">null</span>都会被判断为<span class="built_in">Object</span>，其他判断都正确</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">instanceof</span> 只能判断引用数据类型,不能判断基本数据类型</span><br><span class="line">(<span class="number">3</span>) <span class="title">constructor</span> 它有2个作用 一是判断数据的类型，二是对象实例通过<span class="title">constructor</span>对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,<span class="title">constructor</span>就不能来判断数据类型了</span><br><span class="line">(<span class="params"><span class="number">4</span></span>) <span class="title">Object</span>.<span class="title">prototype</span>.<span class="title">toString</span>.<span class="title">call</span>(<span class="params"></span>) 使用 <span class="title">object</span> 对象的原型方法 <span class="title">tostring</span> 来判断数据类型</span><br><span class="line"></span><br><span class="line"><span class="title">instanceof</span>和<span class="title">typeof</span>的区别：</span><br><span class="line"></span><br><span class="line"><span class="title">instanceof</span>  返回值为布尔值。用于判断一个变量是否属于某个对象的实例。</span><br><span class="line"></span><br><span class="line"><span class="title">typeof</span>  返回值是一个字符串， 用来说明变量的数据类型。</span><br><span class="line"><span class="title">typeof</span> 一般只能返回如下几个结果： <span class="title">number</span>, <span class="title">boolean</span>, <span class="title">string</span>, <span class="title">function</span>, <span class="title">object</span>, <span class="title">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="怎么把类数组转换为数组"><a href="#怎么把类数组转换为数组" class="headerlink" title="怎么把类数组转换为数组"></a>怎么把类数组转换为数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过call调用数组的slice方法来实现转换</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call调用数组的splice方法来实现转换</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过apply调用数组的concat方法来实现转换</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([],arrayLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.from方法来实现转换</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike)</span><br></pre></td></tr></table></figure>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="keyword">let</span> b = <span class="number">2</span>;  如果在不声明第三个变量的前提下，使a=<span class="number">2</span>, b=<span class="number">1</span>？</span><br><span class="line"></span><br><span class="line">答案：[a, b] = [b, a]</span><br></pre></td></tr></table></figure>

<h3 id="如何利用es6快速的去重？"><a href="#如何利用es6快速的去重？" class="headerlink" title="如何利用es6快速的去重？"></a>如何利用es6快速的去重？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">23</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">21</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> item = [...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure>

<h3 id="Promise-面试题-以下代码的执行结果是？"><a href="#Promise-面试题-以下代码的执行结果是？" class="headerlink" title="Promise 面试题 以下代码的执行结果是？"></a>Promise 面试题 以下代码的执行结果是？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        resolve()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">答案：<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：以上考察的是关于promise的原理，promise的构造函数是-同步执行-的，当<span class="keyword">new</span> <span class="built_in">Promise</span>的一瞬间，<span class="number">1</span>,<span class="number">2</span> 就立刻被执行，而 .then方法是-异步执行-的，当执行完<span class="number">1</span>和<span class="number">2</span>之后，会执行输出<span class="number">4</span>，最后执行输出<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...补充中</span><br></pre></td></tr></table></figure>
    </div>
    
        <div style="text-align:center;color: #000;font-size:16px;">------ The End ------</div>

    
    
    
    
        <div class="reward-container">
  <div>您的认可是我不断进步的动力！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="小川 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="小川 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/05/10/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98css/" rel="prev" title="前端面试题-css(补充中...)">
      <i class="fa fa-chevron-left"></i> 前端面试题-css(补充中...)
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/05/20/interview/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98vue/" rel="next" title="前端面试题-vue(补充中...)">
      前端面试题-vue(补充中...) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Var%E3%80%81-let-%E3%80%81const-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">Var、 let 、const 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">ES6声明变量的六种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">函数声明与函数表达式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">函数柯里化 参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.</span> <span class="nav-text">宏任务和微任务到底是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E4%B8%BA-NaN-Not-a-Number%EF%BC%8C%E9%9D%9E%E6%95%B0%E5%AD%97"><span class="nav-number">6.</span> <span class="nav-text">如何判断变量为 NaN( Not a Number，非数字)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null-%E5%92%8C-undefined-%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">null 和 undefined 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">JS实现继承的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88"><span class="nav-number">9.</span> <span class="nav-text">内存中的堆和栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="nav-number">10.</span> <span class="nav-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9D%A5%E5%8C%BA%E5%88%86js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84-%E6%AF%94%E5%A6%82%E5%8C%BA%E5%88%86%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">11.</span> <span class="nav-text">如何来区分js数据类型的?比如区分对象和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%82%E8%80%831%E3%80%81%E5%8F%82%E8%80%832"><span class="nav-number">12.</span> <span class="nav-text">前端开发中常用的几种设计模式 参考1、参考2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F-amp-amp-%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">单例模式——饿汉模式&amp;&amp;懒汉模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%AD%97%E6%AE%B5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">14.</span> <span class="nav-text">在数组对象中添加新字段的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E7%BB%93%E6%9D%9F"><span class="nav-number">15.</span> <span class="nav-text">forEach用什么方法结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%95%B0%E7%BB%84-%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E6%95%B0%E7%BB%84"><span class="nav-number">16.</span> <span class="nav-text">伪数组 转化为真数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%AC%A6%E2%80%9D%E2%80%A6%E2%80%9D"><span class="nav-number">17.</span> <span class="nav-text">扩展符”…”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">18.</span> <span class="nav-text">?? &#x2F; ?. &#x2F; || &#x2F; !! &#x2F;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB"><span class="nav-number">19.</span> <span class="nav-text">数组方法汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">20.</span> <span class="nav-text">数组常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind%E3%80%81call%E3%80%81apply-%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">bind、call、apply 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">本地存储的方式有哪些？区别及应用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%92%8C-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">23.</span> <span class="nav-text">闭包？闭包使用场景 和 什么是立即执行函数?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">深拷贝浅拷贝的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">25.</span> <span class="nav-text">JavaScript中的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="nav-number">26.</span> <span class="nav-text">防抖和节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">27.</span> <span class="nav-text">箭头函数和普通函数有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%81%9A%E8%BF%87%E4%BB%80%E4%B9%88"><span class="nav-number">28.</span> <span class="nav-text">你是怎么理解面向对象的，什么是面向对象，用面向对象做过什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">30.</span> <span class="nav-text">如何解决数字精度丢失的问题?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">JavaScript 中内存泄漏的几种情况？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeScript-%E5%92%8CJavaScript%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">32.</span> <span class="nav-text">TypeScript 和JavaScript有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">JS中的三种事件模型是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95-1"><span class="nav-number">34.</span> <span class="nav-text">ES6声明变量的六种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-1"><span class="nav-number">35.</span> <span class="nav-text">JS实现继承的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">36.</span> <span class="nav-text">原型，原型链 ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">37.</span> <span class="nav-text">说说你对作用域链的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB"><span class="nav-number">38.</span> <span class="nav-text">typeof 与 instanceof 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax%E3%80%81axios%E3%80%81jsonp%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">39.</span> <span class="nav-text">ajax、axios、jsonp的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="nav-number">40.</span> <span class="nav-text">ajax的请求过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99get-%E5%92%8Cpost%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">41.</span> <span class="nav-text">ajax请求的时候get 和post方式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">42.</span> <span class="nav-text">什么是事件委托以及优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM%E6%93%8D%E4%BD%9C%E4%B8%8EBOM%E6%93%8D%E4%BD%9C"><span class="nav-number">43.</span> <span class="nav-text">DOM操作与BOM操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">44.</span> <span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AFvue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="nav-number">45.</span> <span class="nav-text">前端vue解决跨域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E5%92%8C-Map%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">46.</span> <span class="nav-text">Set 和 Map有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">47.</span> <span class="nav-text">常见的检测数据类型的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%8A%8A%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="nav-number">48.</span> <span class="nav-text">怎么把类数组转换为数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">49.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8es6%E5%BF%AB%E9%80%9F%E7%9A%84%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">如何利用es6快速的去重？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">Promise 面试题 以下代码的执行结果是？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-1"><span class="nav-number">52.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-2"><span class="nav-number">53.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-3"><span class="nav-number">54.</span> <span class="nav-text"></span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小川"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">小川</p>
  <div class="site-description" itemprop="description">留一片空白，随时浓墨重彩</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://www.baidu.com/" title="GitHub → https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.baidu.com/" title="E-Mail → https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.baidu.com/" title="Weibo → https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.baidu.com/" title="Google → https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链招募
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">QQ</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">c-Aurora</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'QEQDMymbqdYDItNVBzdBqnUn-gzGzoHsz',
      appKey     : 'TaEvJ4eQniNlzT5ZSaiXfoxT',
      placeholder: "ヾﾉ≧∀≦)o来啊,快活啊!",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  <script type="text/javascript" src="/js/jquery.js"></script>
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- 鼠标点击显示字体效果 -->
  <script type="text/javascript" src="/js/click_show_text.js"></script>
  <!-- 雪花特效 -->
  <!-- <script type="text/javascript" src="/js/snow.js"></script> -->
</body>
</html>
